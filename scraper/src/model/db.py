from scraper.src.exception.db_exception import *
import pymysql

class DB:
    def __init__(self, dbConf: dict) -> None:
        self._db = pymysql.connect(**dbConf)
        self._cursor = self._db.cursor()
        self._dbName = dbConf['database']

    def createTable(self, className: type):
        tableName = className.dbTableName()
        if self.existsTable(className):
            raise TableExistsError('tableName')
        try:
            self._cursor.execute(className.dbCreateTable())
            self._db.commit()
        except Exception as e:
            self._db.rollback()
            raise e

    def dropTable(self, className: type):
        tableName = className.dbTableName()
        if self.existsTable(className):
            self._cursor.execute('drop table ' + tableName)
            self._db.commit()
        else:
            self._db.rollback()
            raise TableNotExistsError('tableName')

    def existsTable(self, className: type):
        tableName = className.dbTableName()
        return self._cursor.execute("show tables where tables_in_" + self._dbName + " = '" + tableName + "'")

    def exists(self, obj):
        return self._cursor.execute(obj.dbExists()) > 0
    
    def existsIfCondition(self, className, obj):
        conditionDict = obj.toConditionDict()
        return self._cursor.execute(className.getEquals(conditionDict)) != 0
    
    def select(self, className, obj) -> list:
        # return primary key list
        conditionDict = obj.toConditionDict()
        self._cursor.execute(className.getEquals(conditionDict))
        res = []
        for row in self._cursor.fetchall():
            selectedObj = className()
            res.append(primaryKey)
        return res
    
    def selectAll(self, className) -> list:
        columns = self._cursor.execute()
        resString = self._cursor.execute(className.selectAll())
        
    def insert(self, className, insertDict):
        try:
            self._cursor.execute(className.insert(insertDict))
            self._db.commit()
        except Exception as e:
            self._db.rollback()
            raise e

    def insertIfNotExists(self, obj):
        # you shouldn't use this
        # you should use insert
        try:
            if not self.exists(obj):
                rowAffected = self._cursor.execute(obj.dbInsert())
            self._db.commit()
            return rowAffected
        except Exception as e:
            self._db.rollback()
            raise e
    
    def insertIfNotExistsAll(self, objs):
        try:
            rowAffected = 0
            for obj in objs:
                if not self.exists(obj):
                    rowAffected += self._cursor.execute(obj.dbInsert())
            self._db.commit()
            return rowAffected
        except Exception as e:
            self._db.rollback()
            raise e
    
    def update(self, className, conditionDict, updateDict):
        try:
            if self._cursor.execute(className.update(conditionDict, updateDict)) != 1:
                raise UnexceptedModifiedRowCount('conditionDict')
            self._db.commit()
        except Exception as e:
            self._db.rollback()
            raise e
    
    def insertOrUpdate(self, className, conditionDict, updateDict):
        if self.existsIfCondition(className, conditionDict):
            self.update(className, conditionDict, updateDict)
        else:
            self.insert(className, updateDict)

    def clear(self):
        pass

    def close(self):
        self._db.close()