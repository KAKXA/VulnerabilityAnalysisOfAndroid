from ..exception.db_exception import *
import pymysql

class DB:
    def __init__(self, dbConf: dict) -> None:
        self._db = pymysql.connect(**dbConf)
        self._cursor = self._db.cursor()
        self._dbName = dbConf['database']

    def createTable(self, className: type):
        tableName = className.dbTableName()
        if self.existsTable(className):
            raise TableExistsError('tableName')
        try:
            self._cursor.execute(className.dbCreateTable())
            self._db.commit()
        except Exception as e:
            self._db.rollback()
            raise e

    def dropTable(self, className: type):
        tableName = className.dbTableName()
        if self.existsTable(className):
            self._cursor.execute('drop table ' + tableName)
            self._db.commit()
        else:
            self._db.rollback()
            raise TableNotExistsError('tableName')

    def existsTable(self, className: type):
        tableName = className.dbTableName()
        return self._cursor.execute("show tables where tables_in_" + self._dbName + " = '" + tableName + "'")

    def exists(self, obj):
        return self._cursor.execute(obj.dbExists()) > 0
        
    def insertIfNotExists(self, obj):
        try:
            if not self.exists(obj):
                rowAffected = self._cursor.execute(obj.dbInsert())
            self._db.commit()
            return rowAffected
        except Exception as e:
            self._db.rollback()
            raise e
    
    def insertIfNotExistsAll(self, objs):
        try:
            rowAffected = 0
            for obj in objs:
                if not self.exists(obj):
                    rowAffected += self._cursor.execute(obj.dbInsert())
            self._db.commit()
            return rowAffected
        except Exception as e:
            self._db.rollback()
            raise e
    
    def clear(self):
        pass

    def close(self):
        self._db.close()